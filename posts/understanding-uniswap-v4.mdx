---
title: "Uniswap v4 Hooks – A Deep Dive and Explanation"
date: "2025-07-17"
description: "A comprehensive guide to Uniswap v4 hooks: from basic concepts to advanced implementations including MEV protection, dynamic fees, and custom AMM behaviors"
tags:
  [
    "uniswap",
    "ethereum",
    "defi",
    "hooks",
    "amm",
    "smart-contracts",
    "mev",
    "dynamic-fees",
  ]
---

# Uniswap v4 Hooks – A Deep Dive and Explanation

## Overview of Uniswap v4 Hooks and What’s New

Uniswap v4 introduces **Hooks** – external smart contracts that can attach to liquidity pools to inject custom logic at certain points in the pool’s operation. In essence, a hook acts like a **plugin** for a Uniswap pool, allowing developers to override or extend default behavior (fees, swaps, liquidity changes, etc.) with their own Solidity code. This is a significant departure from Uniswap v3, which had a fixed protocol logic – in v3 any new feature (like dynamic fees or custom oracles) required deploying an entirely new AMM contract. By contrast, Uniswap v4’s hooks make the core protocol **extensible** without modifying its base code.

**How Hooks Differ from Previous Versions:** In Uniswap v3, pool behavior was mostly static (e.g. fee tiers were fixed and set at pool creation, and a built-in price oracle was provided with every pool). Developers and integrators had no way to execute custom code during swaps or liquidity changes – adding features like time-weighted average pricing, dynamic fees, or custom liquidity incentives meant building separate protocols outside Uniswap. Uniswap v4 changes this by allowing arbitrary code execution at key points in the pool lifecycle via hooks. For example, Uniswap v4 hooks can implement features such as dynamic fee schedules, on-chain limit orders, custom price curves, or MEV protection that would have **not been possible to inject into Uniswap v3’s immutable pools**. In short, hooks give Uniswap v4 a flexible, programmable architecture, turning it into a platform for custom AMM behavior rather than a one-size-fits-all AMM.

From a high-level perspective, each Uniswap v4 liquidity pool _may have at most one hook contract attached_, specified at the time of pool creation (pool initialization). Hooks are **optional** – pools without an attached hook simply run the default Uniswap logic with no custom behavior. If a hook is used, it applies only to that specific pool (allowing fine-grained per-pool customization), although a single hook contract can be reused by multiple pools if desired. The hooks mechanism is built into the Uniswap v4 core, meaning the core contract (the `PoolManager` singleton) knows how to call out to the hook contract at predefined moments during operations like swaps or liquidity updates.

## How Hooks Integrate into Uniswap v4 Architecture

Under the hood, Uniswap v4 employs a **singleton architecture**: all pools are managed by one master contract called the `PoolManager` (instead of deploying a separate contract for each pool as in v3). The `PoolManager` holds the state of all pools and orchestrates pool operations. Hooks tie into this design by serving as **callbacks**: whenever a pool with an attached hook is triggered (by a swap, adding liquidity, etc.), the `PoolManager` will call the corresponding function on the external hook contract at the appropriate time. This is possible because each pool’s identity (its “pool key”) in Uniswap v4 includes not just the token pair and fee, but also a reference to the hook’s address (or a null reference if no hook).

To keep hook calls efficient, Uniswap v4 uses a clever mechanism: the **hook contract’s _address_ encodes which hook functions it implements**. The `PoolManager` inspects specific _bits_ of the hook’s address to determine if a given callback (e.g. `beforeSwap` or `afterAddLiquidity`) should be invoked. Essentially, the hook address acts as a bitmask of permissions – if the least significant bits indicate a particular function is enabled, the `PoolManager` will attempt to call that function on the hook contract. This design avoids storing a boolean flag for each hook function, saving gas. It also makes hook capabilities immutable: once a hook is deployed at an address, its set of enabled callbacks is fixed (since contract addresses on Ethereum cannot be changed). In practice, deploying a hook therefore involves choosing an address with the correct bit pattern (developers typically use the provided `BaseHook` utility, which helps validate that the deployed address matches the declared hook functions). If there’s a mismatch – say the address indicates `beforeSwap` is enabled but the contract doesn’t actually implement `beforeSwap()` – the hook’s constructor (via `BaseHook`) will prevent deployment or the calls would revert. This ensures hook contracts are consistent about the callbacks they provide.

&#x20;_Figure: High-level architecture of Uniswap v4 with hooks. Hook contracts sit between users and the Uniswap core (PoolManager) at defined integration points. Users typically interact with Uniswap via a router or position manager, which calls into the `PoolManager` for swaps or liquidity actions. The `PoolManager` in turn invokes the external Hook at the appropriate points (Hook–v4 interface). In some cases, users or other contracts can also call a Hook directly (user–hook interface) if the Hook is designed to initiate pool actions itself. Uniswap’s core enforces safety checks on hook calls to prevent a malicious hook from breaking pool invariants._

Once a pool is created with an attached hook, the lifecycle of each pool operation includes optional hook calls. At runtime, the `PoolManager` will **check the hook flags** for that pool and execute hook logic as needed. For example, a swap in a hook-enabled pool will proceed roughly as follows:

&#x20;_Figure: Swap execution flow with hooks. When a swap is initiated on a Uniswap v4 pool, the `PoolManager` checks if a `beforeSwap` hook is set for the pool. If **yes**, it calls the hook’s `beforeSwap` function **before** executing the core swap logic (this is where custom pre-swap behavior can run). The swap then executes as normal in the core AMM. After the swap, the `PoolManager` checks for an `afterSwap` hook and calls it **after** the core swap logic completes, allowing post-swap custom actions. If either hook flag is not set (False), that callback is simply skipped with no effect. Both hook functions can return data to the core contract: for instance, `beforeSwap` may return an adjusted fee rate, and `afterSwap` may return a token delta to adjust final balances._

In this way, the Uniswap core and the hook contract cooperate during a swap: the core contract hands control to the hook at defined points, and the hook can influence the swap by its return values or by calling back into the core for certain actions. Similar hook injection points exist for liquidity provision and other actions (described in detail below). If no hook is attached to a pool, the `PoolManager` simply skips any hook-related checks, so the overhead is minimal. This modular architecture is powerful – it means Uniswap v4’s base contracts don’t need to include every feature, and instead third-party hooks can customize pools as needed. However, it also means the behavior of pools can diverge widely depending on their hook, which has implications for security and integration (more on that later).

## Hook Callback Points in the Pool Lifecycle

Uniswap v4 defines **ten** hook functions (five pairs of `before/after` callbacks) corresponding to major events in a pool’s lifecycle. A hook contract can implement any subset of these callbacks, depending on what behavior it wants to customize. Below is a breakdown of each hook point and its purpose:

- **Initialize Hooks:** `beforeInitialize` and `afterInitialize` – called around the initial setup of a new pool (when the pool’s price and parameters are first initialized). These run **once** in a pool’s lifetime. They can be used to perform custom setup, validations, or emit events when a pool is created. For example, a `beforeInitialize` hook might enforce that certain conditions (like allowed token types or an initial price range) are met before a pool can initialize, and an `afterInitialize` hook might log the pool creation to an external registry.

- **Liquidity Modification Hooks:** `beforeAddLiquidity`, `afterAddLiquidity`, `beforeRemoveLiquidity`, `afterRemoveLiquidity` – called before/after liquidity is added or removed from the pool. These give extremely granular control over liquidity events. For instance, a `beforeAddLiquidity` hook could **validate or modify** a deposit (e.g., restrict who can add liquidity or impose a fee on deposits), while an `afterAddLiquidity` hook might perform actions like staking the LP tokens or auto-compounding fees into the position. Likewise, `beforeRemoveLiquidity` can be used to enforce conditions on withdrawals (such as a timelock to prevent instant rug-pulls of liquidity), and `afterRemoveLiquidity` might, say, pay a bonus reward to the liquidity provider on withdrawal. Uniswap v4 separates add and remove hooks (instead of a single “modify liquidity” hook) because adding vs. removing liquidity have different security implications. In particular, a hook that only affects adding liquidity (and not removals) is safer for LPs – it means the hook can’t prevent LPs from withdrawing their funds. V4’s design allows a hook to permit `beforeAddLiquidity` while leaving `beforeRemoveLiquidity` disabled (as reflected in the hook’s address bits), ensuring LPs are guaranteed to exit if the hook only influences deposits.

- **Swap Hooks:** `beforeSwap` and `afterSwap` – called around a swap execution. These are among the most powerful hooks. The `beforeSwap` hook runs _right before_ the core swap logic, and it can be used to enforce custom swap constraints or **dynamically adjust parameters like fees**. In fact, Uniswap v4 allows a `beforeSwap` hook to override the pool’s fee for that particular swap by returning a new fee value (often called `lpFeeOverride`). This enables **dynamic fee AMMs**, where the fee tier isn’t fixed but can respond to market conditions (volatility, trade size, etc.). We’ll see an example of this in the dynamic fee hook below. The `afterSwap` hook runs _after_ the swap’s core logic and can be used to adjust or redistribute the outcome of the trade. For example, `afterSwap` can return a **hook delta** (a `BalanceDelta`) which modifies how the swapped tokens are distributed between the trader and the hook contract. This is part of **custom accounting**: the hook can take a cut of tokens or provide a rebate by altering final balances. `afterSwap` could implement things like a protocol fee (diverting a portion of the swap output to the hook/treasury) or even complex behaviors like outputting a different token (e.g., rewarding the trader in another token). If neither swap hook is implemented, the swap proceeds normally with the pool’s static fee and standard constant-product math.

- **Donate Hooks:** `beforeDonate` and `afterDonate` – called around “donate to liquidity” operations. Uniswap v4 introduced a **donate()** function which lets anyone send tokens directly into a pool’s reserves (effectively tipping the liquidity providers without getting any LP tokens in return). The donate hooks allow customizing this process. For instance, a `beforeDonate` hook could reject donations from certain addresses (if a project only wants certain sources of funds), and an `afterDonate` hook might reward the donor with something (like minting them a separate reward token or NFT to acknowledge their contribution). Donate hooks are a more niche feature but illustrate that _every_ major action in v4 can have custom logic attached.

A hook contract does not need to implement all these functions – it can pick and choose. When deploying a hook, the developer typically overrides a function `getHookPermissions()` (as part of the `BaseHook` class) to return a bitmask or struct indicating which of the above callbacks are active. Only those marked `true` will be called by the `PoolManager`. The _type_ of each hook function’s return value is strictly defined by the v4 core interface and must be respected. For example, all `beforeX`/`afterX` hooks return a `bytes4` selector (to confirm their execution) and _some_ return additional data: notably `beforeSwap` may return a `(bytes4, uint24)` where the uint24 is a fee override, and `afterSwap` (if marked to return a delta) returns `(bytes4, BalanceDelta)` where `BalanceDelta` specifies token amounts to credit/debit the user vs. hook. If a hook returns malformed data or the wrong type, the transaction will revert – so developers must implement the hooks exactly as specified in the Uniswap v4 interface.

## Benefits of Using Hooks in Uniswap v4

Hooks make Uniswap v4 far more **flexible and extensible**, unlocking a range of new possibilities for decentralized finance. Some key benefits of the hooks architecture include:

- **Custom AMM Behavior:** Hooks allow developers to create pools with _custom swap pricing formulas or rules_, beyond Uniswap’s default constant-product formula. For example, one could implement a **constant-sum market maker, a TWAMM, or other bespoke curves** entirely via a hook. The hook can override how swaps behave by using the _custom accounting_ feature (returning token deltas) to simulate a different curve while still relying on Uniswap v4’s underlying infrastructure (concentrated liquidity math, flash accounting, etc.). This means new AMM designs can be prototyped _on top of_ Uniswap rather than as separate protocols. In fact, the Uniswap v4 whitepaper notes you could even recreate a Uniswap v2-style constant product AMM inside a v4 hook – effectively _“Uniswap v2 on Uniswap v4”_ – to leverage v4’s gas optimizations while running a different formula.

- **Dynamic Fees and Custom Fee Distribution:** Unlike v3’s static fee tiers, v4 hooks enable **dynamic swap fees** that change based on conditions (market volatility, time of day, etc.). A hook can adjust a pool’s fee on the fly for each swap (or periodically), which lets pools charge higher fees during high volatility (protecting LPs from impermanent loss) and lower fees during stable periods (attracting more volume). Hooks can also allocate swap fees in flexible ways – for instance, part of the fee can go to the liquidity providers and part can go to a **third-party** (such as the hook developer, a protocol treasury, an insurance fund, etc.). This wasn’t possible in previous versions except for the fixed protocol fee that Uniswap governance could turn on. With hooks, a pool’s creator can define their own fee split or even **different fee structures for different users** (via whitelists or referral programs). This opens the door to innovative business models on top of liquidity pools (e.g. a pool that sends a portion of fees to a specific DAO or uses fees to buy back and burn a token).

- **Rich New Functionality:** Hooks essentially turn Uniswap into a **general-purpose DeFi platform**. Developers have demonstrated many novel use cases for hooks, such as on-chain limit order execution, automated liquidity management, and MEV-mitigation techniques. For example, hooks can implement **on-chain limit orders** that execute when a certain price is reached, or automatically route unused (out-of-range) liquidity into lending protocols to earn extra yield for LPs. Other proposed hook designs include **auto-compounding** (where swap fees earned by LPs are immediately reinvested into their position via the hook), **volatility oracles** that record price variance over time, **time-weighted average market makers (TWAMM)** that execute large trades gradually, and mechanisms to **internalize MEV** (maximal extractable value) by having the pool capture arbitrage profits that would normally go to bots. The Uniswap v4 documentation and community have highlighted many such ideas, underscoring that hooks dramatically broaden Uniswap’s capabilities.

- **Isolation and Composability:** A big advantage of hooks is that they allow experimentation **without forking or risking the core protocol**. A hook’s logic affects only its specific pool(s); if a hook has a bug or undesirable behavior, it doesn’t directly impact other pools. This isolation can reduce systemic risk. At the same time, hooks benefit from composability – since they use the common interface of Uniswap v4, they can be integrated with existing wallets, routers, and analytics with minimal changes (as long as those tools are hook-aware). Also, because Uniswap v4 uses a **singleton contract and flash accounting**, even if hooks lead to many more pools (potentially one per custom use case), trades that route through multiple pools remain efficient. Pool creation in v4 is 99% cheaper than v3, and multi-hop trades in a single transaction don’t suffer the cost of transferring tokens between separate contracts for each hop. This means the ecosystem can support a large number of specialized pools without making trading prohibitively expensive or fragmented.

- **Developer Velocity and Modularity:** For developers, hooks provide a more **agile development model**. Instead of implementing a full AMM from scratch (which requires extensive auditing of math, token handling, etc.), one can leverage Uniswap v4’s well-audited core and focus only on the custom logic in the hook. This lowers the barrier to creating new DeFi innovations. The Uniswap Foundation noted that a team can “bootstrap the codebase of an entirely new DeFi protocol through hook designs, driving down audit costs and allowing faster development”. For example, if you want to build a specialized exchange (say, one with an elaborate fee distribution or an oracle-based pricing rule), you can do so as a hook on Uniswap v4 rather than reinventing the entire AMM mechanism. This modular approach fosters a library of plug-and-play hooks (indeed, an “awesome hooks” repository has already catalogued many community-contributed hooks) and could lead to **standards** for certain hook behaviors. It’s a bit like Uniswap v4 provides the engine and chassis of a car, and hooks let you customize the steering, suspension, and paint job to build your own vehicle on that foundation.

Of course, with these benefits come **tradeoffs**. One practical consideration is that not all hooks will be surfaced in the primary Uniswap UI or widely adopted by aggregators. Just because you deploy a custom pool with a fancy hook doesn’t guarantee traders will use it. Liquidity and volume tend to concentrate in a few well-known pools. Uniswap’s documentation cautions that creating a hook doesn’t automatically get you “liquidity routed to your hook from the Uniswap frontend”. There may be a discoverability and trust hurdle – users might stick to default pools unless a hook’s value proposition is clear and the community deems it safe. Additionally, hooks inherently add **complexity** and surface area for things to go wrong, which we examine next.

## Security Considerations and Gas Costs of Hooks

While hooks greatly expand Uniswap’s capabilities, they also introduce **new security considerations** that both hook developers and users must keep in mind. In prior Uniswap versions, the core code was relatively simple and uniform across pools, making its behavior easier to audit and reason about. Hooks, on the other hand, mean that _each pool could have arbitrary custom code executing_ during swaps or liquidity updates. This flexibility creates potential risks:

- **Hook Contract Security:** A hook is a regular smart contract and can contain bugs or malicious code. If a hook is written poorly or maliciously, it could, for example, steal funds from users who interact with that pool, block liquidity withdrawals, or violate economic assumptions. Users interacting with a pool need to trust _both_ the Uniswap v4 core _and_ the hook’s logic. For instance, a malicious hook could impose an extremely high fee or siphon a portion of each swap to an attacker-controlled address. The Uniswap team emphasizes that hook developers must implement proper validation and access control in their hooks. A notable best practice is to **restrict who can call the hook’s functions**: generally only the Uniswap `PoolManager` should be invoking the hook callbacks. Hook functions like `beforeSwap` or `afterAddLiquidity` by default are public functions – if a developer doesn’t add a modifier to restrict access, _anyone_ could call these functions on the hook contract outside of the normal pool workflow. This could lead to unintended consequences (e.g. someone could call `beforeSwap` directly with fake parameters to trick the hook’s internal state). The Uniswap v4 periphery provides a `SafeCallback`/`BaseHook` utility that includes an `onlyPoolManager` modifier for the critical `unlockCallback()` function (used in flash accounting), but developers **must also protect the other callbacks** as needed. Failing to do so is a common mistake observed in early hook implementations and can be dangerous.

- **Pool Invariants and Core Protection:** On the Uniswap core side, the `PoolManager` does include measures to protect itself (and the pool funds) from a malicious hook. All hook calls occur within the scope of the core contract’s execution, and Uniswap v4 uses a **locking mechanism** (flash accounting with transient storage) to ensure the pool’s balances end up correct at the end of a transaction. For example, if a hook tries to withdraw more tokens from the pool than it is allowed, the final balance check will fail and the transaction will revert, preserving funds. Additionally, Uniswap likely wraps hook calls in `try/catch` or similar, so if a hook call itself reverts unexpectedly or runs out of gas, the whole swap or liquidity action will revert – nothing half-executes. This means a misbehaving hook can’t permanently trap pool funds (though it can block the operation from completing). From a design perspective, Uniswap v4’s hooks have **immutable permissions** (as enforced by the address bits), which ensures that even upgradable or proxy-based hooks cannot suddenly enable new callbacks that weren’t intended, and each hook can’t interfere with parts of the pool’s process it doesn’t have permission for. Moreover, hooks execute in a specific order relative to core logic (always before or after, never in the middle of core execution) which makes reasoning about state changes easier and prevents hooks from, say, breaking the price math mid-swap. Nonetheless, if hooks are configured incorrectly (for example, a hook’s address bits say it implements `afterSwap` but its code doesn’t, causing a call to a non-existent function), it will cause transactions to revert. The `BaseHook` contract’s constructor checks for this mismatch and refuses to deploy in such cases, helping developers catch errors early.

- **User Considerations:** From a user’s standpoint, interacting with a pool that has a custom hook is not the same as interacting with a standard Uniswap pool. There may be **hidden rules or fees**. For instance, a hook might reject trades above a certain size (creating a sort of circuit breaker), or could require the user hold a certain NFT to swap (e.g., a “NFT holders only” pool). There are already examples of hooks enforcing whitelist or KYC rules on pools. Users (and integrator applications) need to be aware of these potential differences. This also means more diligence is required – just as one wouldn’t interact with an arbitrary new DeFi contract without review, one should be cautious about new Uniswap v4 pools with unknown hooks. The Uniswap community is developing resources like **Hook explorer** dashboards and safety score systems to help identify what a given hook does and whether it’s considered safe.

- **Emergency Measures:** If a hook-enabled pool behaves maliciously or unpredictably, the recourse is limited since Uniswap v4 is immutable. However, governance could potentially **turn off routing** to that pool from official interfaces or, in extreme cases, incentivize users to migrate liquidity. Uniswap v4 also introduced a concept of **“subscribers”** (not to be confused with hooks) where an external contract can subscribe to LP position changes – this is more for liquidity mining, but a similar concept could be used to monitor hook activity. The official docs also mention an emergency security hotline (SEAL 911) for reporting exploits. These are community/process safeguards rather than on-chain, but they form part of the security considerations around using hooks.

On the **gas cost** side, hooks do introduce overhead to pool operations, though the design tries to minimize unnecessary costs. When a pool has an attached hook, each time an action occurs the `PoolManager` might make an external call (or two) to the hook contract. An external call from a contract costs on the order of 700–2100 gas just for the call frame, plus any additional computation the hook performs. If the hook reads or writes storage, that’s additional gas. Thus, a swap or add-liquidity in a hooked pool will generally be slightly more expensive in gas than the same action in a vanilla pool. The more complex the hook logic, the more gas it will consume. Developers need to be mindful of this tradeoff: **each hook callback adds gas cost to user operations.** A recent analysis noted that each hook invocation (CALL or DELEGATECALL) costs roughly 700–2100 gas by itself. This is relatively minor (on the order of 1-2k gas) but can add up if multiple hooks are called frequently.

One saving grace is that if a hook doesn’t implement a given callback, the cost to skip it is very low – just a bit check and a conditional jump in the `PoolManager`. So pools without hooks, or with only some hooks enabled, don’t pay overhead for nonexistent hooks. In fact, by removing certain features from the core (like the always-on price oracle of v3), Uniswap v4 actually **reduced** the base gas cost for swaps when those features aren’t needed. For example, v4 doesn’t automatically record oracle prices each block (because you could do that in a hook if desired), saving about _15,000 gas on the first swap of each block_ for pools that don’t need an oracle update. This exemplifies the “pay only for what you use” philosophy – the base protocol is leaner, and extra costs are opt-in via hooks.

That said, some hook use cases will inherently add nontrivial gas. Consider a **dynamic fee hook** that updates the fee on every swap based on volatility: it might query an oracle, do some math, and then call back to update the fee. This ensures accurate real-time adjustments, but as a result “each swap transaction incurs additional gas overhead” for those calculations. An optimization could be to update fees less frequently (e.g. only when volatility changes beyond a threshold, perhaps triggered by an off-chain bot calling a function). In general, there is a design choice between doing more on-chain via hooks (fully automated, but higher per-transaction gas) versus doing some work off-chain or at intervals (less gas per trade, but more complexity and potentially less up-to-date data). Hook developers need to strike a balance depending on the use case.

Finally, it’s worth noting that hooks execute within the same transaction as the core operation, so if a hook’s logic is too gas-heavy, it could make swaps prohibitively expensive or even hit block gas limits. For example, a hook that tries to do complex computations or loop over a lot of data on every swap could render the pool impractical. Gas-intensive hooks may also price themselves out of MEV protection (if a transaction is too costly, arbitrage bots might avoid it). Efficient Solidity coding and, if needed, off-chain computation are important to keep hooks viable. In summary, **hooks inevitably add some gas cost**, but Uniswap v4’s architecture keeps the cost as low as possible when hooks are not used, and it’s up to hook designers to minimize overhead when they are used.

## Example 1: Simple Protocol Fee Collector Hook (Beginner-Level)

To illustrate a basic hook design, let’s start with a straightforward example: a hook that **collects a portion of each swap’s fees and transfers it to a treasury address**. This is akin to a “protocol fee” or royalty that goes to some designated account (for example, a DAO’s treasury or a token issuer’s wallet), on top of the liquidity providers’ share.

**Goal:** Whenever a trade occurs in the pool, the hook will take a small cut of the trade (or of the fee) and send it to a specified address (the treasury). Liquidity providers still get their normal fee minus this cut. This kind of mechanism could be used by a project that creates a pool for its token and wants to fund its treasury or by a fork of Uniswap that enforces a fee switch.

**How it works:** In Uniswap v4, swap fees are now highly configurable. A pool can have a static fee or a hook-managed fee, and importantly, **the hook can allocate a percentage of fees to itself**. Typically, the way to implement a treasury fee is:

- Set the pool’s fee (the total fee charged to traders) slightly higher than what LPs should receive, and let the hook take the difference. For example, if you want LPs to effectively get a 0.3% fee and send 0.05% to the treasury, you might set the pool fee at 0.35%. The hook will keep 0.05% and the remaining 0.30% goes to LPs.

- The hook contract would declare that it implements `afterSwap` (and possibly `beforeSwap` if it needs to adjust something pre-swap). In `afterSwap`, the hook can calculate the portion of the swap outcome that corresponds to the treasury fee and transfer it. There are a couple of ways to do this. One is by using the **hook return delta**: the `afterSwap` function can return a `BalanceDelta` that effectively withholds the treasury amount from the trader’s output and credits it to the hook. In simpler terms, if the trader would normally receive X tokens from the swap, the hook’s return value can reduce that to X – δ, and δ tokens end up in the hook contract’s balance instead (these δ tokens represent the treasury fee cut). The hook contract can then send those tokens to the treasury address. Alternatively, the hook might not use the return delta and instead actively call a transfer to the treasury within the `afterSwap` function using the tokens it receives as part of the swap fees.

- Uniswap v4’s design makes this quite convenient: since the hook can designate itself to receive a portion of fees, the core will actually transfer that portion to the hook (or leave it in hook’s balance via custom accounting) by default, so the hook just needs to forward it to the final destination as needed. The allocation to the hook is configured when the pool is created by setting the hook permissions appropriately (there’s a flag for whether swap fees are sent to the hook or not).

For a concrete scenario, imagine a pool for TOKEN/ETH that a project deploys with a hook. They choose a 1% swap fee, of which they want 0.25% to go to LPs and 0.75% to their treasury (these numbers are arbitrary for illustration). In Uniswap v3, this wasn’t possible – LPs got whatever the fee tier was, and at most a small portion could be diverted to the Uniswap governance treasury (if activated). But in v4, the project can set up their hook such that 0.75% of each trade’s value is skimmed to the project treasury. The hook’s `afterSwap` would execute _after_ the normal swap math is done. It might look at the swap’s result (say the trader is supposed to get 1000 TOKEN out), calculate 7.5 TOKEN as the 0.75% fee, and adjust the outputs so the trader gets 992.5 TOKEN and the remaining 7.5 TOKEN are sent to the treasury. This can be done by returning a `BalanceDelta` of +7.5 TOKEN to the hook (meaning the hook gains 7.5 TOKEN) and -7.5 TOKEN from the trader’s amount. The net effect is the pool’s reserves and LPs see a 1% fee taken, but LPs only receive 0.25% worth (their share), and the treasury gets the rest.

This beginner-level hook is conceptually simple and safe (as long as the percentages are set correctly) – it doesn’t interfere with prices or do anything complex, it just siphons fees. Many projects are interested in this kind of feature to monetize liquidity or ensure sustainability. In fact, there are already community examples: **Flaunch** is a hook that directs **100% of trading fees to creators and buybacks** (essentially a custom fee routing for token launches), and another hook called **Ref Fee Hook** implements referral fees on swaps (sharing a portion of fees with a referrer) in a similar spirit. These demonstrate how easy it is to build fee-on-transfer or fee-sharing logic with hooks.

From a user perspective, the only difference in a pool using a treasury fee hook is they’d get slightly less output on each trade (since part of it goes to the treasury). Everything else – the swap execution and pricing – can remain identical to a normal Uniswap pool. This kind of hook also highlights the **immutability of hook logic**: if the project sets a 0.75% treasury fee, it’s encoded in the hook contract and its address bits. They can’t later arbitrarily change it to 5% without deploying a new hook contract and migrating liquidity (or using an upgradable proxy hook, which users would be wary of). In many cases, that’s a desirable property for trust: LPs and traders know the rules won’t change unless they opt into a new pool.

In summary, this simple hook uses `afterSwap` to take a cut of fees and send to a treasury. It showcases the **ease of extending Uniswap’s fee logic**: Uniswap v4 natively supports static fees, but with a few lines of hook code you can implement custom fee routing to any address or use (treasury, buy-and-burn, charity, etc.). Projects could thus create sustainable liquidity pools that fund their operations, all while using Uniswap’s proven core contracts.

## Example 2: Volatility-Based Dynamic Fee Hook (Intermediate-Level)

One of the headline features enabled by Uniswap v4 hooks is **dynamic trading fees** – fees that change based on market conditions, rather than a fixed percentage. This example will explore a hook that adjusts the swap fee according to the **realized volatility** of the asset pair in question. The motivation is to protect liquidity providers (LPs) during turbulent times and offer traders better rates during calm times, thereby improving the market’s overall efficiency.

**Scenario:** Consider a Uniswap v4 pool for GOLD/SILVER (to take a metaphor from a certain _Captain Hook_ Medium article). In periods of high price volatility between gold and silver, LPs face higher impermanent loss risk, so we’d like the pool to charge a higher fee (e.g. 1%) to compensate LPs. In stable periods with low volatility, the pool can afford to charge a low fee (e.g. 0.05%) to attract more trading volume. In between, a medium fee (say 0.3%) might be used. This mimics the tiered fee structure of Uniswap v3 (which had 0.05%, 0.3%, 1% tiers) but instead of being fixed per pool, _the pool can move between tiers dynamically based on volatility_. Such a design can be achieved with a dynamic fee hook.

**How it works:** We deploy a hook that implements the **dynamic fee interface**. Uniswap v4 allows a pool’s fee to be controlled by the hook if the pool is created with the “dynamic fee” flag. In practice, this means the `PoolManager` will call a function on the hook contract (often `getFee()` or similar) whenever it needs to update the fee. The hook’s job is to return the appropriate fee for the current conditions. The conditions (volatility in this case) can be measured by an oracle or calculated from price data.

For our gold-silver example, we assume there’s an on-chain volatility oracle that computes the recent realized volatility of the price (perhaps based on price feed data or an EMA of price changes). The hook will use this oracle’s output to decide the fee tier:

- If volatility > 14% (high volatility), use a **1% (100 bps)** fee.
- If volatility is between 10% and 14% (moderate volatility), use a **0.3% (30 bps)** fee.
- If volatility < 10% (low volatility), use a **0.05% (5 bps)** fee.

These thresholds and fees are just examples (drawn from a reference implementation), but they illustrate a possible scheme. The hook could even interpolate a continuous fee, but a few discrete tiers are simpler and often sufficient.

When a trader initiates a swap in this pool, here’s what happens: The `beforeSwap` hook is triggered (since the pool is dynamic-fee enabled) and the hook will ensure the current fee is up-to-date. One approach (as described in an example hook) is for `beforeSwap` to call `poolManager.updateDynamicSwapFee(poolKey)` which prompts the core contract to query the hook’s `getFee()` function and update the pool’s fee in storage. Alternatively, `beforeSwap` itself could directly return a fee override value, but the typical pattern is using the provided update mechanism. The hook’s `getFee` function runs, reads the volatility oracle, and returns the appropriate fee tier as a `uint24` (Uniswap uses 10000 as 100%, so 100 means 1%). The `PoolManager` receives this and sets the pool’s fee for the swap accordingly. Then the swap executes with that fee. The `afterSwap` hook could also be implemented if we want to, say, allocate a portion of the fee differently, but in a basic dynamic fee hook, `afterSwap` might not be needed – the main logic is adjusting the fee percentage.

This hook demonstrates how **Uniswap v4 can respond to external data in real time**. In v3, each pool’s fee was fixed at creation (with a limited set of choices). If market conditions changed, LPs had to migrate to a different fee-tier pool manually. Here, the pool _itself_ adapts. High-volatility periods, which might correspond to important news events or market stress, automatically make the pool charge more (earning LPs more and dissuading some volume, which helps reduce risk). Low volatility periods make the pool very competitive fee-wise, encouraging arbitragers and traders to use it since it’s cheap, thus tightening spreads. Over time, this could lead to better returns for LPs and better prices for traders than any static fee. It essentially automates the “fee tier selection” that a human LP might do (some advanced LPs in v3 would move their liquidity to a higher fee tier when markets got volatile; the hook does that on the fly).

From a technical standpoint, one challenge is ensuring the oracle data is available and fresh. Our hook in this example relies on a “realized volatility oracle”. This could be something like a feed updated by an off-chain service periodically, or calculated from price history on-chain. For accuracy, you’d want it updated fairly often (maybe every hour or every day). If it’s on-chain, the hook can read it directly; if off-chain, perhaps the hook trusts a feed (which introduces some oracle trust assumptions). The Uniswap team anticipated such use cases, as dynamic fees are highlighted as a key hook use case. They even built in governance controls where Uniswap’s governance can set a cap on fees or take a percentage on top if desired (though governance cannot veto the hook’s logic – it’s more about adding on a protocol fee cap).

It’s important to note that continuously updating fees does incur extra gas. In our example, every swap triggers the fee computation. The Medium article that detailed this scenario explicitly points out that _“this approach introduces an additional gas overhead to every swap transaction”_. The benefit is a always-current fee, but the cost is perhaps a few thousand extra gas per swap (for the oracle read and update call). In some cases, it might be acceptable; in others, one might choose to only update the fee occasionally (e.g. update once per block or have a keeper bot update the fee every hour via a separate transaction). The hook design allows flexibility: you could have `beforeSwap` check a timestamp of last update and only call `updateDynamicSwapFee` if a certain time has passed or a certain volatility change occurred, to save gas on every single swap. This is a design decision for the hook author. Our example does it every swap for simplicity and maximum responsiveness.

Despite the added gas, dynamic fee hooks are compelling. They essentially give a pool an **adaptive fee policy**, something traditional exchanges have done (charging more during high load times, etc.) but which automated market makers are only now exploring. This intermediate example shows how hooks can integrate **external analytics (volatility measurements)** into the AMM logic. The result is a more resilient pool that can, for example, discourage toxic order flow and reduce LP losses during wild market swings by raising fees (and conversely tighten spreads when markets are quiet).

Real-world prototypes of this idea are already being worked on. In the Uniswap community, there’s mention of hooks like **Volatility Fee Hook** and **Dynamic Fee Hook** which specifically target volatility-adjusted fees. These implementations often use oracles (like a volatility oracle from e.g. Chainlink or a custom TWAP-based calculation). As with any oracle-dependent logic, one must consider oracle delays or manipulation, but since the oracle is just informing fees (not directly moving assets), the risk is mainly if the oracle is wrong, the fee might be suboptimal – which is a lesser risk than, say, an oracle directly setting prices.

To sum up, the dynamic fee hook shows the **power of hooks to create more sophisticated pricing models**. It remains compatible with Uniswap’s core in that traders still interact with the pool normally (they might not even realize the fee changed between two swaps unless they look). LPs benefit from a fee that adjusts to conditions, ideally improving their earnings vs. a static fee. This is a nice intermediate complexity hook: it involves external data and on-chain computation, but doesn’t fundamentally alter how swaps or liquidity work, it just adjusts a parameter in a controlled way. When designing such hooks, developers should thoroughly test that the fee updates correctly and that extreme scenarios are handled (e.g., what if the oracle fails or returns an absurd value – perhaps the hook should have a sane max/min fee clamp). They should also weigh the **gas cost vs. benefit** – in some low-margin markets, the extra gas might outweigh the benefit of fee precision, but in high-volume volatile markets, it could be very worthwhile.

## Example 3: Advanced Hooks – MEV Protection and TWAP-Based Execution (Advanced-Level)

For a truly advanced use case, let’s look at how hooks can tackle one of the trickiest problems in DeFi: **MEV (Maximal Extractable Value) and trade execution quality**, as well as enabling complex order types like time-weighted execution. These are more complex than the earlier examples and would be aimed at power users or specialized pools.

### 3A. MEV-Protected Hook (Internalizing MEV for LPs)

MEV refers to the profit that can be extracted by reordering, inserting, or censoring transactions in a block (commonly by arbitrage bots, front-runners, or miners). In AMMs like Uniswap v3, external arbitrageurs often capture profits by taking advantage of price discrepancies – for example, if a large swap moves the price, a bot might immediately trade against the pool to arbitrage it back in line with the broader market, profiting off the price difference and effectively taking value that might otherwise have stayed with LPs or traders. Similarly, sandwich attacks on traders (front-running and back-running their swap to extract value) are a form of MEV.

A hook can be designed to **mitigate or capture MEV**, shifting the advantage away from external actors and towards the pool (LPs or even traders). One approach, sometimes called _MEV internalization_, is to have the hook monitor for arbitrage opportunities and execute them _on behalf of the pool_ so that the profit goes to LPs. Concretely, the hook can integrate with a price oracle (like a highly reliable external price feed) to detect if the pool’s price has diverged from the oracle price beyond a threshold. If it has, that usually means there’s an arbitrage opportunity. Instead of leaving it for an outside bot, the hook could proactively take action: for instance, in an `afterSwap` hook, after each trade it could compare the new pool price to the oracle price. If the swap left the pool price off by, say, 1%, the hook could initiate a counter-swap (or adjust the output) to push the price back towards the oracle, effectively capturing that 1% difference for the pool. Alternatively, the hook might charge an extra fee to the trader equal to the expected arbitrage profit (since the trader’s swap created that arbitrage gap) and add it to the pool reserves or distribute to LPs.

A concrete example is the **Detox Hook** (developed at an ETHGlobal hackathon) which _“uses Pyth oracle data to detect arbitrage, capture profits, and redirect value back to liquidity providers”_. In practice, such a hook’s `afterSwap` might compute the hypothetical profit an arbitrageur would make (by comparing pool price vs oracle price and the pool’s liquidity) and then take an equivalent amount of tokens from the swap’s output as a fee. This means the arbitrage opportunity is gone (because the trade itself paid the difference), and that difference is kept in the pool (benefiting LPs). To an external observer, it looks like the pool had a slightly worse price for that trader – indeed the trader who caused the big price swing would effectively pay the arbitrage cost – but this deters predatory behaviors and compensates LPs for providing liquidity. Another strategy is **restricting who can perform swaps or how they’re executed** to prevent common MEV attacks. For example, the **Angstrom** project uses a hook to only allow _approved validators_ to execute swaps, with the idea that a decentralized network of validators executes trades in a way that defends LPs (perhaps sharing MEV or using specialized ordering). Hooks could also enforce **rate limiting or batch auctions**: e.g., a hook might accumulate trades and execute them at fixed intervals (preventing quick back-to-back sandwiches), or only process one swap per block to foil certain MEV strategies.

From an implementation standpoint, an MEV-protection hook is complex. It needs a reliable price reference (which could be on-chain TWAPs from other protocols or an oracle network like Pyth/Chainlink) and robust logic to enforce the rules. Security is paramount – an error in the logic or oracle feed could mistakenly overcharge traders or undercharge arbitrageurs. Also, such hooks might need to handle edge cases like paused or stale oracles. Nonetheless, the ability to incorporate arbitrary logic means _we can embed policies inside the AMM that were impossible before_. In Uniswap v3, one could not simply say “if price deviates too much, charge extra” – the contract had no notion of external price or conditional fees. Uniswap v4 hooks enable that.

It’s worth noting that MEV protection can sometimes conflict with trader interests – for instance, a trader getting arbitraged (sans hook) might have gotten a slightly better initial price, with the arbitrageur profiting later, whereas a hook that internalizes MEV might give the trader a slightly worse price upfront (taking some profit for LPs). Some designs aim to **help the trader as well**, for example by using a commit-reveal scheme where trades are executed at a fair clearing price rather than the exact moment price (to prevent sandwiches). A hook could enforce that a trade’s price is based on a time-averaged price or that trades are only executed if they don’t exceed a slippage that would invite sandwiches. These are advanced mechanisms and might require coordination beyond just one hook (possibly a network of keepers or a specific ordering service).

In summary, a hook with MEV protection logic serves as an **embedded policy layer** in the AMM that can neutralize typical MEV exploits. It leverages the fact that hooks can have complex logic and oracle access to implement things like _“if pool price far from external price, skim the difference”_ or _“only allow swaps that satisfy certain criteria”_. The result can be a fairer system for LPs (and possibly traders), at the cost of additional complexity and reliance on off-chain data. This example shows how far one can go with hooks: effectively designing a custom _policy_ or _guardian_ for the pool. It’s a burgeoning area of research, blending economics and engineering. Early experiments like the ones referenced (Detox, Angstrom, etc.) indicate that many teams are exploring using hooks to make AMMs more MEV-resilient.

### 3B. TWAP/Time-Delayed Trading Hook (TWAMM & Advanced Order Types)

Another sophisticated application of hooks is enabling **time-weighted average price** trades and other advanced order types (stop-loss, take-profit orders, etc.) directly within the AMM. A _TWAP_ order typically means a large order that is executed gradually over a long interval to mitigate price impact (common in traditional finance). There was an academic concept called TWAMM (Time-Weighted Automated Market Maker) that would split big trades into infinitesimal pieces to execute over time. Uniswap v4 hooks provide an avenue to implement a TWAMM or similar mechanisms on top of a concentrated liquidity pool.

**Use case:** Suppose an investor wants to sell 1,000 ETH for DAI but doesn’t want to move the market too much at once. Instead of swapping all 1,000 ETH in one transaction (which would incur heavy slippage and invite front-running), they could use a TWAMM hook that executes, say, 10 ETH per block over 100 blocks, averaging the price over that period. The hook could automate this so the user doesn’t have to manually submit trades each block.

**How it works:** One design is to use the hook to accept a **long-term order** from the user. For example, the user could call a function on the hook contract (outside the normal swap interface) to commit 1,000 ETH for selling over time. The hook would then, at each opportunity (maybe each block or each few blocks), perform a small swap on the Uniswap pool on behalf of the user (the hook contract might hold the ETH and drip it into the pool). This requires the hook to have the ability to call the `PoolManager` to execute swaps – which it can, since a hook is just a contract and could initiate swaps itself if coded to do so. The hook could use the `beforeSwap`/`afterSwap` callbacks in combination with an internal schedule: for instance, the `beforeSwap` might check if there are pending TWAP orders and take some action like adjusting the trade amount.

Another approach is to implement TWAP pricing rather than orders: i.e., the hook could ensure that any large swap is executed at a price that is an average over a timeframe. How? Perhaps by using a time-delayed oracle of the pool’s price. One could imagine a hook that, on a `beforeSwap`, doesn’t execute immediately at the current pool price, but instead enforces that the swap’s price impact is spread – maybe by executing part now and scheduling the rest. This is quite complex to do synchronously, since Ethereum transactions are atomic. More feasibly, the hook can break up the swap into multiple internal swaps across multiple transactions. This requires storing state in the hook (for example, how much of an order is left to fulfill) and some mechanism (maybe a keeper or the users themselves calling a function) to progress the order.

The **AsyncSwap Hooks** mentioned in Uniswap’s docs hint at such designs. Indeed, the Quickstart guide lists an “AsyncSwap Hooks” category, suggesting hooks that facilitate asynchronous swap settlement or multi-tx swaps. Hooks can maintain internal queues or order books. For example, a **limit order hook** has been built that allows users to place limit orders which execute when the price crosses a threshold. Under the hood, that hook likely intercepts swaps or uses donations to trigger trades when conditions meet, using its logic to decide execution.

For TWAP specifically, a known example is Uniswap’s own research into TWAMM (there was a Paradigm research piece on it). A hook could implement a TWAMM by effectively pairing off long-term orders from buyers and sellers over time and executing small virtual swaps each block. Implementation might involve the hook’s `beforeSwap` reducing large trades to a fraction and storing the rest as a long-term order. Alternatively, the hook might not use the regular swap function at all for long orders, instead using `donate` or a custom method to simulate continuous trading.

Regardless of the exact method, what hooks bring is **programmability to the AMM’s matching engine**. You’re no longer limited to immediate swap = immediate result. You can introduce concepts of time and conditions. A “stop-loss/take-profit” hook, for instance, can watch the price (maybe via Uniswap’s built-in tick or an external feed) and if a certain level is reached, automatically execute a swap on behalf of a user who set up that order. This effectively creates a **decentralized order book** on top of the AMM. Multiple advanced order hooks could coexist with the pool – though note, since only one hook can attach to a pool, one hook contract might need to handle multiple advanced order types, or there needs to be a primary hook that itself manages sub-features (like an order book). Another possibility is using **Subscribers** (another v4 feature) for advanced orders, but hooks can do it in-line as well.

One current limitation is that all hook logic still executes within a single transaction initiated by someone. For truly automated multi-block execution, you either need users to trigger their own orders or some bot to call a function each block. Hooks don’t give magical background execution without transactions. However, hooks can be written so that _any_ swap or action on the pool triggers some maintenance logic. E.g., a hook could piggyback on every swap to also settle pending TWAP orders up to that block. Or a hook might use the `afterDonate` function (which a keeper could call each block as a harmless action) to do housekeeping.

The intricacy of advanced time-based hooks is why this is an “advanced” example. You have to coordinate across time and possibly between multiple users’ intents. Nonetheless, community prototypes exist: the **TWAMM hook** listed in Uniswap’s examples and things like **Super DCA** (a hook that implements dollar-cost averaging and dynamic fees). There’s even an example of an **on-chain take-profit order hook** in tutorials.

To illustrate one approach simply: imagine a hook that implements TWAMM by utilizing the pool’s **donate** function each block. The hook could take the user’s large order, and then each block it “donates” a small amount of one token to the pool and, in exchange, withdraws a small amount of the other token via the pool’s pricing (this could be done by a tiny swap). By doing so repeatedly, the large order is executed piecewise. The donate hooks (`beforeDonate/afterDonate`) might be used to automate this exchange in increments.

From a safety perspective, advanced hooks like these are essentially building a mini exchange on top of Uniswap. They need thorough testing. One must ensure that partial executions don’t leave the pool in a bad state or that a malicious user can’t exploit the mechanism (e.g., what if someone tries to front-run the TWAP process itself – hooks have to consider that and perhaps randomize or restrict execution to prevent new vectors of MEV).

In conclusion, advanced hooks for MEV protection and time-delayed pricing demonstrate the **extreme flexibility** of Uniswap v4’s design. We can embed logic that was traditionally in separate systems (like MEV relays, off-chain order books, or layer-2 solutions) directly into the AMM at the smart contract level. This tight integration could lead to more efficient and fair outcomes, but it requires complex logic and often external data or agents. Uniswap v4 provides the canvas, and hook developers can paint virtually any trading rule or mechanism on it – from compliant KYC-gated pools to privacy-enhanced swaps using zero-knowledge proofs to the advanced order types we discussed. The hooks architecture essentially turns Uniswap into a **decentralized exchange construction kit**.

---

**Conclusion:** Uniswap v4 hooks represent a major leap in AMM design, blending the liquidity advantages of Uniswap’s protocol with the customizability of smart contract logic. We started with the basics – how hooks attach to pools and the points at which they can intervene – and saw how this allows everything from simple fee redirects to sophisticated dynamic behaviors. The key takeaway is that hooks make Uniswap v4 _not a single AMM, but a whole family of AMMs_ living under one roof. Each pool can have its own rules while still benefiting from shared liquidity infrastructure and optimizations. Developers get unprecedented control to innovate (with clear responsibilities to uphold security best practices), and users get access to more specialized financial products (albeit with the need for greater awareness of each pool’s custom rules). Uniswap v4’s hook system is still in its early days (as of 2025, many hooks are experimental), but it has opened the floodgates for creativity in DeFi. We’re likely to see a rich ecosystem of hooks addressing use cases we haven’t even imagined yet – all plugged into Uniswap’s core, like modules extending its functionality. It’s an exciting development in the evolution of decentralized exchanges, marrying the reliability of a proven protocol with the ingenuity of the open developer community.

**Sources:**

- Uniswap v4 Core Whitepaper
- Uniswap v4 Documentation
- CertiK Analysis of Uniswap v4 Hooks
- Community Resources and Examples
- Medium Tutorial on Dynamic Fee Hook
- Gas Cost & Security Discussion
